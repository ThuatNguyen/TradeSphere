"""Zalo OA webhook and messaging endpoints"""
from fastapi import APIRouter, HTTPException, Request, Header, Depends, BackgroundTasks
from typing import Optional, List
import re
from ....schemas import (
    ZaloWebhookEvent, ZaloSendMessageRequest, ZaloSendMessageResponse,
    BroadcastCampaignCreate, BroadcastCampaignResponse, 
    BroadcastStatsResponse, BroadcastSendRequest
)
from ....services import zalo_service, crawler_service, ai_service
from ....database import get_db
from ....models import ZaloUser, ZaloMessage, BroadcastCampaign, BroadcastLog
from sqlalchemy.orm import Session
from sqlalchemy import desc
from datetime import datetime

router = APIRouter()


def is_phone_number(text: str) -> bool:
    """Check if text is a phone number"""
    # Vietnamese phone number patterns
    pattern = r'^(0|\+84)[0-9]{9,10}$'
    clean_text = re.sub(r'[\s\-\.]', '', text.strip())
    return bool(re.match(pattern, clean_text))


def is_bank_account(text: str) -> bool:
    """Check if text is a bank account number"""
    # Bank account: 6-16 digits
    pattern = r'^[0-9]{6,16}$'
    clean_text = text.strip()
    return bool(re.match(pattern, clean_text))


def is_url(text: str) -> bool:
    """Check if text contains URL"""
    url_pattern = r'https?://[^\s]+|www\.[^\s]+|[^\s]+\.(com|vn|org|net|io|me|edu|gov)[^\s]*'
    return bool(re.search(url_pattern, text.lower()))


def extract_searchable_keyword(text: str) -> str:
    """Extract searchable keyword from text (phone, account, or URL)"""
    # Try phone number first
    if is_phone_number(text):
        return re.sub(r'[\s\-\.]', '', text.strip())
    
    # Try bank account
    if is_bank_account(text):
        return text.strip()
    
    # Try URL
    url_match = re.search(r'https?://([^\s]+)|www\.([^\s]+)|([^\s]+\.(com|vn|org|net|io|me|edu|gov))', text.lower())
    if url_match:
        # Extract domain or full URL
        for group in url_match.groups():
            if group:
                return group.split('/')[0]  # Get domain only
    
    return text.strip()


async def format_scam_results_for_zalo(results: dict, keyword: str) -> str:
    """Format scam search results for Zalo message with link"""
    
    # Generate checkscam link
    checkscam_link = f"https://thuatnguyen.io.vn/scam-search?keyword={keyword}"
    
    if results.get("total_results", 0) == 0:
        return f"""‚úÖ KH√îNG T√åM TH·∫§Y C·∫¢NH B√ÅO

T·ª´ kh√≥a: {keyword}
Tr·∫°ng th√°i: Ch∆∞a c√≥ b√°o c√°o l·ª´a ƒë·∫£o

‚ö†Ô∏è L∆∞u √Ω: Kh√¥ng c√≥ b√°o c√°o ‚â† An to√†n 100%
Lu√¥n c·∫©n th·∫≠n khi giao d·ªãch ti·ªÅn b·∫°c!

üîç Xem chi ti·∫øt: {checkscam_link}
üí° G·ª≠i tin nh·∫Øn ƒë·ªÉ t√¥i t∆∞ v·∫•n th√™m."""
    
    message = f"""üö® PH√ÅT HI·ªÜN C·∫¢NH B√ÅO

T·ª´ kh√≥a: {keyword}
T·ªïng s·ªë b√°o c√°o: {results['total_results']}

"""
    
    has_results = False
    for source in results.get("sources", []):
        if source.get("success") and source.get("data"):
            total = source.get("total_scams", 0)
            if isinstance(total, str) and total.isdigit():
                total = int(total)
            
            if total > 0:
                has_results = True
                source_name = source.get("source", "").upper()
                message += f"üìå {source_name}: {total} b√°o c√°o\n"
                
                # Show top 2 results
                for item in source["data"][:2]:
                    name = item.get("name", "N/A")
                    date = item.get("date", "N/A")
                    message += f"  ‚Ä¢ {name}\n"
                    if date and date != "N/A":
                        message += f"    üìÖ {date}\n"
                
                message += "\n"
    
    if has_results:
        message += f"‚ö†Ô∏è C·∫¢NH B√ÅO: C√≥ th·ªÉ l√† l·ª´a ƒë·∫£o!\n"
        message += f"üîç Xem chi ti·∫øt: {checkscam_link}\n"
        message += f"\nüí° Tip: Kh√¥ng chuy·ªÉn ti·ªÅn cho s·ªë/t√†i kho·∫£n n√†y!"
    else:
        message += f"‚ÑπÔ∏è C√≥ d·ªØ li·ªáu nh∆∞ng ch∆∞a c√≥ b√°o c√°o c·ª• th·ªÉ\n"
        message += f"üîç Ki·ªÉm tra th√™m: {checkscam_link}"
    
    return message


@router.post("/webhook")
async def zalo_webhook(
    request: Request,
    x_zalo_signature: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """
    Webhook endpoint for Zalo OA events
    
    Handles:
    - user_send_text: Text messages from users
    - user_send_image: Image messages
    - follow: User follows OA
    - unfollow: User unfollows OA
    """
    try:
        # Get raw body for signature verification
        body = await request.body()
        
        # Verify signature (in production)
        # if not zalo_service.verify_signature(body, x_zalo_signature):
        #     raise HTTPException(status_code=401, detail="Invalid signature")
        
        # Parse event
        data = await request.json()
        event_name = data.get("event_name")
        
        if event_name == "user_send_text":
            await handle_text_message(data, db)
        elif event_name == "user_send_image":
            await handle_image_message(data, db)
        elif event_name == "follow":
            await handle_follow(data, db)
        elif event_name == "unfollow":
            await handle_unfollow(data, db)
        
        return {"status": "ok"}
        
    except Exception as e:
        print(f"Webhook error: {e}")
        return {"status": "error", "message": str(e)}


async def handle_text_message(data: dict, db: Session):
    """Handle text message from user"""
    try:
        sender = data.get("sender", {})
        user_id = sender.get("id")
        message_data = data.get("message", {})
        message_text = message_data.get("text", "").strip()
        
        if not user_id or not message_text:
            return
        
        # Save incoming message
        incoming_msg = ZaloMessage(
            zalo_user_id=user_id,
            message_type="text",
            message_content=message_text,
            is_from_user=True
        )
        db.add(incoming_msg)
        db.commit()
        
        # Process message
        response_text = ""
        
        if message_text.lower() in ["/help", "help", "h∆∞·ªõng d·∫´n"]:
            response_text = """ü§ñ H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG

G·ª≠i cho t√¥i:
üì± S·ªë ƒëi·ªán tho·∫°i - Ki·ªÉm tra SƒêT l·ª´a ƒë·∫£o
üí≥ S·ªë t√†i kho·∫£n - Ki·ªÉm tra STK ng√¢n h√†ng
ÔøΩ Link website - Ki·ªÉm tra trang web l·ª´a ƒë·∫£o
üí¨ Tin nh·∫Øn/Email - Ph√¢n t√≠ch n·ªôi dung
‚ùì C√¢u h·ªèi - T∆∞ v·∫•n ph√≤ng ch·ªëng l·ª´a ƒë·∫£o

V√≠ d·ª•:
- 0123456789
- 1234567890
- https://example.com
- "B·∫°n ƒë√£ tr√∫ng th∆∞·ªüng 100 tri·ªáu..."

G√µ /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n n√†y."""
            
        elif is_phone_number(message_text):
            # Search phone number
            keyword = extract_searchable_keyword(message_text, "phone")
            search_result = await crawler_service.search_all_sources(keyword)
            response_text = await format_scam_results_for_zalo(search_result, keyword)
            
        elif is_bank_account(message_text):
            # Search bank account
            keyword = extract_searchable_keyword(message_text, "account")
            search_result = await crawler_service.search_all_sources(keyword)
            response_text = await format_scam_results_for_zalo(search_result, keyword)
            
        elif is_url(message_text):
            # Search URL/domain
            keyword = extract_searchable_keyword(message_text, "url")
            search_result = await crawler_service.search_all_sources(keyword)
            response_text = await format_scam_results_for_zalo(search_result, keyword)
            
        else:
            # AI chat
            print(f"ü§ñ Calling AI chat for message: {message_text[:50]}...")
            response_text = await ai_service.chat(message_text, context=None)
            print(f"‚úÖ AI response: {response_text[:100]}...")
        
        # Send response
        print(f"üì§ Sending response to user {user_id}: {response_text[:100]}...")
        send_result = await zalo_service.send_text_message(user_id, response_text)
        print(f"üì® Send result: {send_result}")
        
        # Save outgoing message
        outgoing_msg = ZaloMessage(
            zalo_user_id=user_id,
            message_type="text",
            message_content=response_text,
            is_from_user=False
        )
        db.add(outgoing_msg)
        db.commit()
        
    except Exception as e:
        print(f"Handle text message error: {e}")
        db.rollback()


async def handle_image_message(data: dict, db: Session):
    """Handle image message from user"""
    try:
        sender = data.get("sender", {})
        user_id = sender.get("id")
        
        response_text = """üì∏ C·∫£m ∆°n b·∫°n ƒë√£ g·ª≠i h√¨nh ·∫£nh!

T√≠nh nƒÉng ph√¢n t√≠ch h√¨nh ·∫£nh ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.
Hi·ªán t·∫°i, b·∫°n c√≥ th·ªÉ:
- G·ª≠i s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ ki·ªÉm tra
- G·ª≠i s·ªë t√†i kho·∫£n ƒë·ªÉ tra c·ª©u
- H·ªèi t√¥i v·ªÅ ph√≤ng ch·ªëng l·ª´a ƒë·∫£o"""
        
        await zalo_service.send_text_message(user_id, response_text)
        
        # Save message
        incoming_msg = ZaloMessage(
            zalo_user_id=user_id,
            message_type="image",
            message_content="[Image]",
            is_from_user=True
        )
        db.add(incoming_msg)
        db.commit()
        
    except Exception as e:
        print(f"Handle image message error: {e}")
        db.rollback()


async def handle_follow(data: dict, db: Session):
    """Handle user follow event"""
    try:
        follower = data.get("follower", {})
        user_id = follower.get("id")
        
        if not user_id:
            return
        
        # Get user profile
        profile = await zalo_service.get_user_profile(user_id)
        profile_data = profile.get("data", {})
        
        # Save or update user
        zalo_user = db.query(ZaloUser).filter(ZaloUser.zalo_user_id == user_id).first()
        
        if not zalo_user:
            zalo_user = ZaloUser(
                zalo_user_id=user_id,
                display_name=profile_data.get("display_name", ""),
                avatar=profile_data.get("avatar", ""),
                is_active=True
            )
            db.add(zalo_user)
        else:
            zalo_user.is_active = True
            zalo_user.display_name = profile_data.get("display_name", zalo_user.display_name)
            zalo_user.avatar = profile_data.get("avatar", zalo_user.avatar)
        
        db.commit()
        
        # Send welcome message
        welcome_text = """üéâ Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Anti-Scam!

T√¥i l√† tr·ª£ l√Ω AI gi√∫p b·∫°n:
‚úÖ Ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i l·ª´a ƒë·∫£o
‚úÖ Tra c·ª©u t√†i kho·∫£n ng√¢n h√†ng
‚úÖ Ph√¢n t√≠ch tin nh·∫Øn nghi ng·ªù
‚úÖ T∆∞ v·∫•n ph√≤ng ch·ªëng l·ª´a ƒë·∫£o

üí° G·ª≠i /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n chi ti·∫øt.

H√£y g·ª≠i s·ªë ƒëi·ªán tho·∫°i ho·∫∑c c√¢u h·ªèi ƒë·ªÉ b·∫Øt ƒë·∫ßu! üîç"""
        
        await zalo_service.send_text_message(user_id, welcome_text)
        
    except Exception as e:
        print(f"Handle follow error: {e}")
        db.rollback()


async def handle_unfollow(data: dict, db: Session):
    """Handle user unfollow event"""
    try:
        follower = data.get("follower", {})
        user_id = follower.get("id")
        
        if not user_id:
            return
        
        # Mark user as inactive
        zalo_user = db.query(ZaloUser).filter(ZaloUser.zalo_user_id == user_id).first()
        if zalo_user:
            zalo_user.is_active = False
            db.commit()
        
    except Exception as e:
        print(f"Handle unfollow error: {e}")
        db.rollback()


@router.post("/send", response_model=ZaloSendMessageResponse)
async def send_message(request: ZaloSendMessageRequest):
    """Send message to a specific user (for testing/admin use)"""
    try:
        result = await zalo_service.send_text_message(
            request.user_id,
            request.message
        )
        
        if result.get("error") == 0:
            return ZaloSendMessageResponse(
                success=True,
                message_id=result.get("data", {}).get("message_id")
            )
        else:
            return ZaloSendMessageResponse(
                success=False,
                error=result.get("message")
            )
            
    except Exception as e:
        return ZaloSendMessageResponse(
            success=False,
            error=str(e)
        )


@router.get("/followers")
async def get_followers(
    offset: int = 0,
    count: int = 50
):
    """Get list of OA followers"""
    try:
        result = await zalo_service.get_follower_list(offset, count)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ==================== BROADCAST ENDPOINTS ====================

@router.post("/broadcast/create", response_model=BroadcastCampaignResponse)
async def create_broadcast_campaign(
    campaign: BroadcastCampaignCreate,
    db: Session = Depends(get_db)
):
    """
    Create a new broadcast campaign
    
    - **title**: Campaign title
    - **content**: Message content (max 2000 chars)
    - **target**: 'all' (all followers) or 'specific' (custom list)
    - **target_user_ids**: List of user IDs if target='specific'
    - **scheduled_time**: Schedule for later (optional)
    """
    try:
        # Validate target
        if campaign.target == "specific" and not campaign.target_user_ids:
            raise HTTPException(
                status_code=400,
                detail="target_user_ids is required when target='specific'"
            )
        
        # Create campaign
        db_campaign = BroadcastCampaign(
            title=campaign.title,
            content=campaign.content,
            target=campaign.target,
            target_user_ids=campaign.target_user_ids,
            scheduled_time=campaign.scheduled_time,
            status='scheduled' if campaign.scheduled_time else 'draft',
            created_by='admin'  # TODO: Get from auth
        )
        
        db.add(db_campaign)
        db.commit()
        db.refresh(db_campaign)
        
        return db_campaign
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/broadcast/{campaign_id}/send")
async def send_broadcast_campaign(
    campaign_id: int,
    request: BroadcastSendRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Send broadcast campaign immediately or schedule for later
    
    - **send_now**: Send immediately (default: true)
    - **scheduled_time**: Schedule for later (optional)
    """
    try:
        # Get campaign
        campaign = db.query(BroadcastCampaign).filter(
            BroadcastCampaign.id == campaign_id
        ).first()
        
        if not campaign:
            raise HTTPException(status_code=404, detail="Campaign not found")
        
        if campaign.status in ['sending', 'completed']:
            raise HTTPException(
                status_code=400,
                detail=f"Campaign already {campaign.status}"
            )
        
        # Schedule or send now
        if not request.send_now and request.scheduled_time:
            campaign.scheduled_time = request.scheduled_time
            campaign.status = 'scheduled'
            db.commit()
            return {
                "message": f"Campaign scheduled for {request.scheduled_time}",
                "campaign_id": campaign_id
            }
        
        # Send now in background
        campaign.status = 'sending'
        campaign.started_at = datetime.utcnow()
        db.commit()
        
        # Run broadcast in background
        background_tasks.add_task(
            process_broadcast_campaign,
            campaign_id,
            campaign.content,
            campaign.target,
            campaign.target_user_ids
        )
        
        return {
            "message": "Broadcast started",
            "campaign_id": campaign_id,
            "status": "sending"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/broadcast/campaigns", response_model=List[BroadcastCampaignResponse])
async def list_broadcast_campaigns(
    status: Optional[str] = None,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """
    List all broadcast campaigns
    
    - **status**: Filter by status (draft, scheduled, sending, completed, failed)
    - **limit**: Max results (default: 50)
    """
    try:
        query = db.query(BroadcastCampaign)
        
        if status:
            query = query.filter(BroadcastCampaign.status == status)
        
        campaigns = query.order_by(desc(BroadcastCampaign.created_at)).limit(limit).all()
        return campaigns
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/broadcast/{campaign_id}/stats", response_model=BroadcastStatsResponse)
async def get_broadcast_stats(
    campaign_id: int,
    db: Session = Depends(get_db)
):
    """
    Get detailed statistics for a broadcast campaign
    
    Returns:
    - Total users, sent count, success/failed counts
    - Success rate percentage
    - List of failed users with error messages
    """
    try:
        campaign = db.query(BroadcastCampaign).filter(
            BroadcastCampaign.id == campaign_id
        ).first()
        
        if not campaign:
            raise HTTPException(status_code=404, detail="Campaign not found")
        
        # Get failed logs
        failed_logs = db.query(BroadcastLog).filter(
            BroadcastLog.campaign_id == campaign_id,
            BroadcastLog.status == 'failed'
        ).limit(50).all()
        
        failed_users = [
            {
                "user_id": log.zalo_user_id,
                "error": log.error_message or "Unknown error"
            }
            for log in failed_logs
        ]
        
        success_rate = (
            (campaign.success_count / campaign.total_users * 100)
            if campaign.total_users > 0 else 0
        )
        
        return BroadcastStatsResponse(
            campaign_id=campaign.id,
            status=campaign.status,
            total_users=campaign.total_users,
            sent_count=campaign.sent_count,
            success_count=campaign.success_count,
            failed_count=campaign.failed_count,
            started_at=campaign.started_at,
            completed_at=campaign.completed_at,
            success_rate=round(success_rate, 2),
            failed_users=failed_users
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/broadcast/{campaign_id}")
async def delete_broadcast_campaign(
    campaign_id: int,
    db: Session = Depends(get_db)
):
    """Delete a broadcast campaign (only if status is draft or failed)"""
    try:
        campaign = db.query(BroadcastCampaign).filter(
            BroadcastCampaign.id == campaign_id
        ).first()
        
        if not campaign:
            raise HTTPException(status_code=404, detail="Campaign not found")
        
        if campaign.status not in ['draft', 'failed']:
            raise HTTPException(
                status_code=400,
                detail=f"Cannot delete campaign with status '{campaign.status}'"
            )
        
        # Delete logs first
        db.query(BroadcastLog).filter(
            BroadcastLog.campaign_id == campaign_id
        ).delete()
        
        db.delete(campaign)
        db.commit()
        
        return {"message": "Campaign deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))


# Background task for processing broadcast
async def process_broadcast_campaign(
    campaign_id: int,
    message: str,
    target: str,
    target_user_ids: Optional[List[str]]
):
    """Background task to process broadcast campaign"""
    from ....database import SessionLocal
    
    db = SessionLocal()
    try:
        # Get target users
        if target == "specific" and target_user_ids:
            users = target_user_ids
        else:
            # Get all followers
            followers_response = await zalo_service.get_follower_list(offset=0, count=1000)
            followers_data = followers_response.get("data", {})
            followers = followers_data.get("followers", [])
            users = [f["user_id"] for f in followers]
        
        # Update total users
        campaign = db.query(BroadcastCampaign).filter(
            BroadcastCampaign.id == campaign_id
        ).first()
        
        campaign.total_users = len(users)
        db.commit()
        
        # Send broadcast
        result = await zalo_service.send_broadcast(
            message=message,
            target_users=users,
            campaign_id=campaign_id,
            rate_limit_delay=1.5
        )
        
        # Save logs to database
        for log in result.get("logs", []):
            broadcast_log = BroadcastLog(
                campaign_id=campaign_id,
                zalo_user_id=log["user_id"],
                status=log["status"],
                error_message=log.get("error")
            )
            db.add(broadcast_log)
        
        # Update campaign stats
        campaign.sent_count = result["total"]
        campaign.success_count = result["success"]
        campaign.failed_count = result["failed"]
        campaign.status = 'completed'
        campaign.completed_at = datetime.utcnow()
        
        db.commit()
        
        print(f"‚úÖ Campaign {campaign_id} completed: {result['success']}/{result['total']} success")
        
    except Exception as e:
        print(f"‚ùå Campaign {campaign_id} failed: {e}")
        campaign = db.query(BroadcastCampaign).filter(
            BroadcastCampaign.id == campaign_id
        ).first()
        if campaign:
            campaign.status = 'failed'
            db.commit()
    finally:
        db.close()

